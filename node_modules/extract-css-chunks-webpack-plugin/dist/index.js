'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _webpack = require('webpack');

var _webpack2 = _interopRequireDefault(_webpack);

var _webpackSources = require('webpack-sources');

var _webpackSources2 = _interopRequireDefault(_webpackSources);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var hotLoader = _path2.default.resolve(__dirname, './hotLoader.js');

var { ConcatSource, SourceMapSource, OriginalSource } = _webpackSources2.default;
var {
    Template,
    util: { createHash }
} = _webpack2.default;

var MODULE_TYPE = 'css/extract-chunks';

var pluginName = 'extract-css-chunks-webpack-plugin';

var REGEXP_CHUNKHASH = /\[chunkhash(?::(\d+))?\]/i;
var REGEXP_CONTENTHASH = /\[contenthash(?::(\d+))?\]/i;
var REGEXP_NAME = /\[name\]/i;

var isHMR = function (compiler) {
    if (compiler && compiler.options) {
        if (compiler.options.devServer && compiler.options.devServer.hot) {
            return true;
        }

        if (compiler.options.entry) {
            var entry = typeof compiler.options.entry === 'function' ? compiler.options.entry() : compiler.options.entry;
            var entryString = JSON.stringify(entry);
            return entryString.includes('hot') || entryString.includes('hmr');
        }
    }
    return false;
};

class CssDependency extends _webpack2.default.Dependency {
    constructor({ identifier, content, media, sourceMap }, context, identifierIndex) {
        super();
        this.identifier = identifier;
        this.identifierIndex = identifierIndex;
        this.content = content;
        this.media = media;
        this.sourceMap = sourceMap;
        this.context = context;
    }

    getResourceIdentifier() {
        return 'css-module-' + this.identifier + '-' + this.identifierIndex;
    }
}

class CssDependencyTemplate {
    apply() {}
}

class CssModule extends _webpack2.default.Module {
    constructor(dependency) {
        super(MODULE_TYPE, dependency.context);
        this.id = '';
        this._identifier = dependency.identifier;
        this._identifierIndex = dependency.identifierIndex;
        this.content = dependency.content;
        this.media = dependency.media;
        this.sourceMap = dependency.sourceMap;
    }

    // no source() so webpack doesn't do add stuff to the bundle

    size() {
        return this.content.length;
    }

    identifier() {
        return 'css ' + this._identifier + ' ' + this._identifierIndex;
    }

    readableIdentifier(requestShortener) {
        return 'css ' + requestShortener.shorten(this._identifier) + (this._identifierIndex ? ' (' + this._identifierIndex + ')' : '');
    }

    nameForCondition() {
        var resource = this._identifier.split('!').pop();
        var idx = resource.indexOf('?');
        if (idx >= 0) return resource.substring(0, idx);
        return resource;
    }

    updateCacheModule(module) {
        this.content = module.content;
        this.media = module.media;
        this.sourceMap = module.sourceMap;
    }

    needRebuild() {
        return true;
    }

    build(options, compilation, resolver, fileSystem, callback) {
        this.buildInfo = {};
        this.buildMeta = {};
        callback();
    }

    updateHash(hash) {
        super.updateHash(hash);
        hash.update(this.content);
        hash.update(this.media || '');
        hash.update(this.sourceMap ? JSON.stringify(this.sourceMap) : '');
    }
}

class CssModuleFactory {
    create({
        dependencies: [dependency]
    }, callback) {
        callback(null, new CssModule(dependency));
    }
}

class ExtractCssChunks {
    constructor(options) {
        this.options = Object.assign({
            filename: '[name].css'
        }, options);
        var { cssModules, reloadAll } = this.options;

        if (!this.options.chunkFilename) {
            var { filename } = this.options;
            var hasName = filename.includes('[name]');
            var hasId = filename.includes('[id]');
            var hasChunkHash = filename.includes('[chunkhash]');
            // Anything changing depending on chunk is fine
            if (hasChunkHash || hasName || hasId) {
                this.options.chunkFilename = filename;
            } else {
                // Elsewise prefix '[id].' in front of the basename to make it changing
                this.options.chunkFilename = filename.replace(/(^|\/)([^/]*(?:\?|$))/, '$1[id].$2');
            }
        }

        this.hotLoaderObject = Object.assign({
            loader: hotLoader,
            options: {
                cssModules: false,
                reloadAll: false
            }
        }, {
            options: {
                cssModules,
                reloadAll
            }
        });
    }

    apply(compiler) {
        var _this = this;

        try {
            var isHOT = this.options.hot ? true : isHMR(compiler);

            if (isHOT && compiler.options.module && compiler.options.module.rules) {
                compiler.options.module.rules = this.updateWebpackConfig(compiler.options.module.rules);
            }
        } catch (e) {
            throw new Error('Something went wrong: contact the author: ' + JSON.stringify(e));
        }

        compiler.hooks.thisCompilation.tap(pluginName, function (compilation) {
            compilation.hooks.normalModuleLoader.tap(pluginName, function (lc, m) {
                var loaderContext = lc;
                var module = m;
                loaderContext[MODULE_TYPE] = function (content) {
                    if (!Array.isArray(content) && content != null) {
                        throw new Error('Exported value was not extracted as an array: ' + JSON.stringify(content));
                    }

                    var identifierCountMap = new Map();
                    for (var line of content) {
                        var count = identifierCountMap.get(line.identifier) || 0;
                        module.addDependency(new CssDependency(line, m.context, count));
                        identifierCountMap.set(line.identifier, count + 1);
                    }
                };
            });
            compilation.dependencyFactories.set(CssDependency, new CssModuleFactory());
            compilation.dependencyTemplates.set(CssDependency, new CssDependencyTemplate());
            compilation.mainTemplate.hooks.renderManifest.tap(pluginName, function (result, { chunk }) {
                var renderedModules = Array.from(chunk.modulesIterable).filter(function (module) {
                    return module.type === MODULE_TYPE;
                });
                if (renderedModules.length > 0) {
                    result.push({
                        render: function () {
                            return _this.renderContentAsset(compilation, chunk, renderedModules, compilation.runtimeTemplate.requestShortener);
                        },
                        filenameTemplate: _this.options.filename,
                        pathOptions: {
                            chunk,
                            contentHashType: MODULE_TYPE
                        },
                        identifier: pluginName + '.' + chunk.id,
                        hash: chunk.contentHash[MODULE_TYPE]
                    });
                }
            });
            compilation.chunkTemplate.hooks.renderManifest.tap(pluginName, function (result, { chunk }) {
                var renderedModules = Array.from(chunk.modulesIterable).filter(function (module) {
                    return module.type === MODULE_TYPE;
                });
                if (renderedModules.length > 0) {
                    result.push({
                        render: function () {
                            return _this.renderContentAsset(compilation, chunk, renderedModules, compilation.runtimeTemplate.requestShortener);
                        },
                        filenameTemplate: _this.options.chunkFilename,
                        pathOptions: {
                            chunk,
                            contentHashType: MODULE_TYPE
                        },
                        identifier: pluginName + '.' + chunk.id,
                        hash: chunk.contentHash[MODULE_TYPE]
                    });
                }
            });
            compilation.mainTemplate.hooks.hashForChunk.tap(pluginName, function (hash, chunk) {
                var { chunkFilename } = _this.options;
                if (REGEXP_CHUNKHASH.test(chunkFilename)) {
                    hash.update(JSON.stringify(chunk.getChunkMaps(true).hash));
                }
                if (REGEXP_CONTENTHASH.test(chunkFilename)) {
                    hash.update(JSON.stringify(chunk.getChunkMaps(true).contentHash[MODULE_TYPE] || {}));
                }
                if (REGEXP_NAME.test(chunkFilename)) {
                    hash.update(JSON.stringify(chunk.getChunkMaps(true).name));
                }
            });
            compilation.hooks.contentHash.tap(pluginName, function (chunk) {
                var { outputOptions } = compilation;
                var {
                    hashFunction,
                    hashDigest,
                    hashDigestLength
                } = outputOptions;
                var hash = createHash(hashFunction);
                for (var m of chunk.modulesIterable) {
                    if (m.type === MODULE_TYPE) {
                        m.updateHash(hash);
                    }
                }
                var { contentHash } = chunk;
                contentHash[MODULE_TYPE] = hash.digest(hashDigest).substring(0, hashDigestLength);
            });
            var { mainTemplate } = compilation;
            mainTemplate.hooks.localVars.tap(pluginName, function (source, chunk) {
                var chunkMap = _this.getCssChunkObject(chunk);
                if (Object.keys(chunkMap).length > 0) {
                    return Template.asString([source, '', '// object to store loaded CSS chunks', 'var installedCssChunks = {', Template.indent(chunk.ids.map(function (id) {
                        return JSON.stringify(id) + ': 0';
                    }).join(',\n')), '}']);
                }
                return source;
            });
            mainTemplate.hooks.requireEnsure.tap(pluginName, function (source, chunk, hash) {
                var chunkMap = _this.getCssChunkObject(chunk);
                if (Object.keys(chunkMap).length > 0) {
                    var chunkMaps = chunk.getChunkMaps();
                    var {
                        crossOriginLoading
                    } = mainTemplate.outputOptions;
                    var linkHrefPath = mainTemplate.getAssetPath(JSON.stringify(_this.options.chunkFilename), {
                        hash: '" + ' + mainTemplate.renderCurrentHashCode(hash) + ' + "',
                        hashWithLength: function (length) {
                            return '" + ' + mainTemplate.renderCurrentHashCode(hash, length) + ' + "';
                        },
                        chunk: {
                            id: '" + chunkId + "',
                            hash: '" + ' + JSON.stringify(chunkMaps.hash) + '[chunkId] + "',
                            hashWithLength(length) {
                                var shortChunkHashMap = Object.create(null);
                                for (var chunkId of Object.keys(chunkMaps.hash)) {
                                    if (typeof chunkMaps.hash[chunkId] === 'string') {
                                        shortChunkHashMap[chunkId] = chunkMaps.hash[chunkId].substring(0, length);
                                    }
                                }
                                return '" + ' + JSON.stringify(shortChunkHashMap) + '[chunkId] + "';
                            },
                            contentHash: {
                                [MODULE_TYPE]: '" + ' + JSON.stringify(chunkMaps.contentHash[MODULE_TYPE]) + '[chunkId] + "'
                            },
                            contentHashWithLength: {
                                [MODULE_TYPE]: function (length) {
                                    var shortContentHashMap = {};
                                    var contentHash = chunkMaps.contentHash[MODULE_TYPE];
                                    for (var chunkId of Object.keys(contentHash)) {
                                        if (typeof contentHash[chunkId] === 'string') {
                                            shortContentHashMap[chunkId] = contentHash[chunkId].substring(0, length);
                                        }
                                    }
                                    return '" + ' + JSON.stringify(shortContentHashMap) + '[chunkId] + "';
                                }
                            },
                            name: '" + (' + JSON.stringify(chunkMaps.name) + '[chunkId]||chunkId) + "'
                        },
                        contentHashType: MODULE_TYPE
                    });
                    return Template.asString([source, '', '// ' + pluginName + ' CSS loading', 'var cssChunks = ' + JSON.stringify(chunkMap) + ';', 'if(installedCssChunks[chunkId]) promises.push(installedCssChunks[chunkId]);', 'else if(installedCssChunks[chunkId] !== 0 && cssChunks[chunkId]) {', Template.indent(['promises.push(installedCssChunks[chunkId] = new Promise(function(resolve, reject) {', Template.indent(['var href = ' + linkHrefPath + ';', 'var fullhref = ' + mainTemplate.requireFn + '.p + href;', 'var existingLinkTags = document.getElementsByTagName("link");', 'for(var i = 0; i < existingLinkTags.length; i++) {', Template.indent(['var tag = existingLinkTags[i];', 'var dataHref = tag.getAttribute("data-href") || tag.getAttribute("href");', 'if(tag.rel === "stylesheet" && (dataHref === href || dataHref === fullhref)) return resolve();']), '}', 'var existingStyleTags = document.getElementsByTagName("style");', 'for(var i = 0; i < existingStyleTags.length; i++) {', Template.indent(['var tag = existingStyleTags[i];', 'var dataHref = tag.getAttribute("data-href");', 'if(dataHref === href || dataHref === fullhref) return resolve();']), '}', 'var linkTag = document.createElement("link");', 'linkTag.rel = "stylesheet";', 'linkTag.type = "text/css";', 'linkTag.onload = resolve;', 'linkTag.onerror = function(event) {', Template.indent(['var request = event && event.target && event.target.src || fullhref;', 'var err = new Error("Loading CSS chunk " + chunkId + " failed.\\n(" + request + ")");', 'err.request = request;', 'delete installedCssChunks[chunkId]', 'linkTag.parentNode.removeChild(linkTag)', 'reject(err);']), '};', 'linkTag.href = fullhref;', crossOriginLoading ? Template.asString(["if (linkTag.href.indexOf(window.location.origin + '/') !== 0) {", Template.indent('linkTag.crossOrigin = ' + JSON.stringify(crossOriginLoading) + ';'), '}']) : '', 'var head = document.getElementsByTagName("head")[0];', 'head.appendChild(linkTag);']), '}).then(function() {', Template.indent(['installedCssChunks[chunkId] = 0;']), '}));']), '}']);
                }
                return source;
            });
        });
    }

    traverseDepthFirst(root, visit) {
        var nodesToVisit = [root];

        while (nodesToVisit.length > 0) {
            var currentNode = nodesToVisit.shift();

            if (currentNode !== null && typeof currentNode === 'object') {
                var children = Object.values(currentNode);
                nodesToVisit = [...children, ...nodesToVisit];
            }

            visit(currentNode);
        }
    }

    updateWebpackConfig(rulez) {
        var _this2 = this;

        return rulez.reduce(function (rules, rule) {
            _this2.traverseDepthFirst(rule, function (node) {
                if (node && node.use && Array.isArray(node.use)) {
                    var isExtractCss = node.use.some(function (l) {
                        var needle = l.loader || l;
                        if (typeof l === 'function') {
                            return false;
                        }
                        return needle.includes(pluginName);
                    });
                    if (isExtractCss) {
                        node.use.unshift(_this2.hotLoaderObject);
                    }
                }
                if (node && node.loader && Array.isArray(node.loader)) {
                    var _isExtractCss = node.loader.some(function (l) {
                        var needle = l.loader || l;
                        if (typeof l === 'function') {
                            return false;
                        }
                        return needle.includes(pluginName);
                    });
                    if (_isExtractCss) {
                        node.loader.unshift(_this2.hotLoaderObject);
                    }
                }
            });

            rules.push(rule);

            return rules;
        }, []);
    }

    getCssChunkObject(mainChunk) {
        var obj = {};
        for (var chunk of mainChunk.getAllAsyncChunks()) {
            for (var module of chunk.modulesIterable) {
                if (module.type === MODULE_TYPE) {
                    obj[chunk.id] = 1;
                    break;
                }
            }
        }
        return obj;
    }

    renderContentAsset(compilation, chunk, modules, requestShortener) {
        var usedModules = void 0;

        var [chunkGroup] = chunk.groupsIterable;
        if (typeof chunkGroup.getModuleIndex2 === 'function') {
            // Store dependencies for modules
            var moduleDependencies = new Map(modules.map(function (m) {
                return [m, new Set()];
            }));

            // Get ordered list of modules per chunk group
            // This loop also gathers dependencies from the ordered lists
            // Lists are in reverse order to allow to use Array.pop()
            var modulesByChunkGroup = Array.from(chunk.groupsIterable, function (cg) {
                var sortedModules = modules.map(function (m) {
                    return {
                        module: m,
                        index: cg.getModuleIndex2(m)
                    };
                }).filter(function (item) {
                    return item.index !== undefined;
                }).sort(function (a, b) {
                    return b.index - a.index;
                }).map(function (item) {
                    return item.module;
                });
                for (var i = 0; i < sortedModules.length; i++) {
                    var set = moduleDependencies.get(sortedModules[i]);
                    for (var j = i + 1; j < sortedModules.length; j++) {
                        set.add(sortedModules[j]);
                    }
                }

                return sortedModules;
            });

            // set with already included modules in correct order
            usedModules = new Set();

            var unusedModulesFilter = function (m) {
                return !usedModules.has(m);
            };

            while (usedModules.size < modules.length) {
                var success = false;
                var bestMatch = void 0;
                var bestMatchDeps = void 0;
                // get first module where dependencies are fulfilled
                for (var list of modulesByChunkGroup) {
                    // skip and remove already added modules
                    while (list.length > 0 && usedModules.has(list[list.length - 1])) {
                        list.pop();
                    }

                    // skip empty lists
                    if (list.length !== 0) {
                        var module = list[list.length - 1];
                        var deps = moduleDependencies.get(module);
                        // determine dependencies that are not yet included
                        var failedDeps = Array.from(deps).filter(unusedModulesFilter);

                        // store best match for fallback behavior
                        if (!bestMatchDeps || bestMatchDeps.length > failedDeps.length) {
                            bestMatch = list;
                            bestMatchDeps = failedDeps;
                        }
                        if (failedDeps.length === 0) {
                            // use this module and remove it from list
                            usedModules.add(list.pop());
                            success = true;
                            break;
                        }
                    }
                }

                if (!success) {
                    // no module found => there is a conflict
                    // use list with fewest failed deps
                    // and emit a warning
                    var fallbackModule = bestMatch.pop();
                    compilation.warnings.push(new Error('chunk ' + (chunk.name || chunk.id) + ' [extract-css-chunks-plugin]\n' + 'Conflicting order between:\n' + (' * ' + fallbackModule.readableIdentifier(requestShortener) + '\n') + ('' + bestMatchDeps.map(function (m) {
                        return ' * ' + m.readableIdentifier(requestShortener);
                    }).join('\n'))));
                    usedModules.add(fallbackModule);
                }
            }
        } else {
            // fallback for older webpack versions
            // (to avoid a breaking change)
            // TODO remove this in next mayor version
            // and increase minimum webpack version to 4.12.0
            modules.sort(function (a, b) {
                return a.index2 - b.index2;
            });
            usedModules = modules;
        }
        var source = new ConcatSource();
        var externalsSource = new ConcatSource();
        for (var m of usedModules) {
            if (/^@import url/.test(m.content)) {
                // HACK for IE
                // http://stackoverflow.com/a/14676665/1458162
                var { content } = m;
                if (m.media) {
                    // insert media into the @import
                    // this is rar
                    // TODO improve this and parse the CSS to support multiple medias
                    content = content.replace(/;|\s*$/, m.media);
                }
                externalsSource.add(content);
                externalsSource.add('\n');
            } else {
                if (m.media) {
                    source.add('@media ' + m.media + ' {\n');
                }
                if (m.sourceMap) {
                    source.add(new SourceMapSource(m.content, m.readableIdentifier(requestShortener), m.sourceMap));
                } else {
                    source.add(new OriginalSource(m.content, m.readableIdentifier(requestShortener)));
                }
                source.add('\n');
                if (m.media) {
                    source.add('}\n');
                }
            }
        }
        return new ConcatSource(externalsSource, source);
    }
}

ExtractCssChunks.loader = require.resolve('./loader');
ExtractCssChunks.hotLoader = require.resolve('./hotLoader');

exports.default = ExtractCssChunks;