'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.pitch = pitch;

exports.default = function () {};

var _module = require('module');

var _module2 = _interopRequireDefault(_module);

var _loaderUtils = require('loader-utils');

var _loaderUtils2 = _interopRequireDefault(_loaderUtils);

var _NodeTemplatePlugin = require('webpack/lib/node/NodeTemplatePlugin');

var _NodeTemplatePlugin2 = _interopRequireDefault(_NodeTemplatePlugin);

var _NodeTargetPlugin = require('webpack/lib/node/NodeTargetPlugin');

var _NodeTargetPlugin2 = _interopRequireDefault(_NodeTargetPlugin);

var _LibraryTemplatePlugin = require('webpack/lib/LibraryTemplatePlugin');

var _LibraryTemplatePlugin2 = _interopRequireDefault(_LibraryTemplatePlugin);

var _SingleEntryPlugin = require('webpack/lib/SingleEntryPlugin');

var _SingleEntryPlugin2 = _interopRequireDefault(_SingleEntryPlugin);

var _LimitChunkCountPlugin = require('webpack/lib/optimize/LimitChunkCountPlugin');

var _LimitChunkCountPlugin2 = _interopRequireDefault(_LimitChunkCountPlugin);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var MODULE_TYPE = 'css/extract-chunks';
var pluginName = 'extract-css-chunks-webpack-plugin';

var exec = function (loaderContext, code, filename) {
    var module = new _module2.default(filename, loaderContext);
    module.paths = _module2.default._nodeModulePaths(loaderContext.context); // eslint-disable-line no-underscore-dangle
    module.filename = filename;
    module._compile(code, filename); // eslint-disable-line no-underscore-dangle
    return module.exports;
};

var findModuleById = function (modules, id) {
    for (var module of modules) {
        if (module.id === id) {
            return module;
        }
    }
    return null;
};

function pitch(request) {
    var _this = this;

    var query = _loaderUtils2.default.getOptions(this) || {};
    var loaders = this.loaders.slice(this.loaderIndex + 1);
    this.addDependency(this.resourcePath);
    var childFilename = '*'; // eslint-disable-line no-path-concat
    var publicPath = typeof query.publicPath === 'string' ? query.publicPath : this._compilation.outputOptions.publicPath;
    var outputOptions = {
        filename: childFilename,
        publicPath
    };
    var childCompiler = this._compilation.createChildCompiler(pluginName + ' ' + request, outputOptions);
    new _NodeTemplatePlugin2.default(outputOptions).apply(childCompiler);
    new _LibraryTemplatePlugin2.default(null, 'commonjs2').apply(childCompiler);
    new _NodeTargetPlugin2.default().apply(childCompiler);
    new _SingleEntryPlugin2.default(this.context, '!!' + request, pluginName).apply(childCompiler);
    new _LimitChunkCountPlugin2.default({ maxChunks: 1 }).apply(childCompiler);
    // We set loaderContext[MODULE_TYPE] = false to indicate we already in
    // a child compiler so we don't spawn another child compilers from there.
    childCompiler.hooks.thisCompilation.tap(pluginName + ' loader', function (compilation) {
        compilation.hooks.normalModuleLoader.tap(pluginName + ' loader', function (loaderContext, module) {
            loaderContext[MODULE_TYPE] = false; // eslint-disable-line no-param-reassign
            if (module.request === request) {
                // eslint-disable-next-line no-param-reassign
                module.loaders = loaders.map(function (loader) {
                    return {
                        loader: loader.path,
                        options: loader.options,
                        ident: loader.ident
                    };
                });
            }
        });
    });

    var source = void 0;
    childCompiler.hooks.afterCompile.tap(pluginName, function (compilation) {
        source = compilation.assets[childFilename] && compilation.assets[childFilename].source();

        // Remove all chunk assets
        compilation.chunks.forEach(function (chunk) {
            chunk.files.forEach(function (file) {
                delete compilation.assets[file]; // eslint-disable-line no-param-reassign
            });
        });
    });

    var callback = this.async();
    childCompiler.runAsChild(function (err, entries, compilation) {
        if (err) return callback(err);

        if (compilation.errors.length > 0) {
            return callback(compilation.errors[0]);
        }
        compilation.fileDependencies.forEach(function (dep) {
            _this.addDependency(dep);
        }, _this);
        compilation.contextDependencies.forEach(function (dep) {
            _this.addContextDependency(dep);
        }, _this);
        if (!source) {
            return callback(new Error("Didn't get a result from child compiler"));
        }
        var text = void 0;
        var locals = void 0;
        try {
            text = exec(_this, source, request);
            locals = text && text.locals;
            if (!Array.isArray(text)) {
                text = [[null, text]];
            } else {
                text = text.map(function (line) {
                    var module = findModuleById(compilation.modules, line[0]);
                    return {
                        identifier: module.identifier(),
                        content: line[1],
                        media: line[2],
                        sourceMap: line[3]
                    };
                });
            }
            _this[MODULE_TYPE](text);
        } catch (e) {
            return callback(e);
        }
        var resultSource = '// extracted by ' + pluginName;
        if (locals && typeof resultSource !== 'undefined') {
            resultSource += '\nmodule.exports = ' + JSON.stringify(locals) + ';';
        }

        return callback(null, resultSource);
    });
}